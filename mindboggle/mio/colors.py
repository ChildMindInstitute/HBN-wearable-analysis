#!/usr/bin/env python
"""
Colormap-related functions

Authors:
    - Arno Klein, 2016  (arno@mindboggle.info)  http://binarybottle.com

Copyright 2016,  Mindboggle team (http://mindboggle.info), Apache v2.0 License

"""


def distinguishable_colors(ncolors, backgrounds=[[0,0,0],[1,1,1]],
                           save_csv=True, plot_colormap=True, verbose=True):
    """
    Create a colormap of perceptually distinguishable colors.

    This program is a Python program based on Tim Holy's 2010-2011
    BSD-licensed Matlab program "distinguishable_colors.m"
    (https://www.mathworks.com/matlabcentral/fileexchange/
     29702-generate-maximally-perceptually-distinct-colors):

    "This function generates a set of colors which are distinguishable
    by reference to the "Lab" color space, which more closely matches
    human color perception than RGB. Given an initial large list of possible
    RGB colors, it iteratively chooses the entry in the list that is farthest
    (in Lab space) from all previously-chosen entries. While this "greedy"
    algorithm does not yield a global maximum, it is simple and efficient.
    Moreover, the sequence of colors is consistent no matter how many you
    request, which facilitates the users' ability to learn the color order
    and avoids major changes in the appearance of plots when adding or
    removing lines."

    Parameters
    ----------
    ncolors : integer
        number of colors for the colormap
    backgrounds : list of list(s) of 3 elements between 0 and 1
        rgb background colors to initialize and distinguish from
    save_csv : Boolean
        save colormap as csv file?
    plot_colormap : Boolean
        plot colormap as horizontal bar chart?
    verbose : Boolean
        print to stdout?

    Returns
    -------
    colors : numpy ndarray of ndarrays of 3 floats between 0 and 1
        rgb colormap

    Examples
    --------
    >>> from mindboggle.mio.colors import distinguishable_colors
    >>> ncolors = 31
    >>> backgrounds = [[0,0,0],[1,1,1]]
    >>> save_csv = False
    >>> plot_colormap = False
    >>> verbose = False
    >>> colors = distinguishable_colors(ncolors, backgrounds,
    ...     save_csv, plot_colormap, verbose)
    >>> colors[0]
    array([ 0.62068966,  0.06896552,  1.        ])
    >>> colors[1]
    array([ 0.       ,  0.5862069,  0.       ])
    >>> colors[2]
    array([ 0.75862069,  0.20689655,  0.        ])

    """
    import numpy as np
    import matplotlib.pyplot as plt
    from colormath.color_objects import LabColor, AdobeRGBColor
    from colormath.color_conversions import convert_color
    from colormath.color_diff import delta_e_cie2000

    filename = "colormap_of_{0}_distinguishable_colors".format(ncolors)

    # ------------------------------------------------------------------------
    # Generate a sizable number of RGB triples. This represents our space of
    # possible choices. By starting in RGB space, we ensure that all of the
    # colors can be generated by the monitor:
    # ------------------------------------------------------------------------
    n_grid = 30  # number of grid divisions along each axis in RGB space
    x = np.linspace(0, 1, num=n_grid, endpoint=True)
    R, G, B = np.meshgrid(x, x, x)
    ncolors_total = np.size(R)
    RGB = np.vstack([np.ravel(R), np.ravel(G), np.ravel(B)])
    RGB = [[RGB[0][icolor], RGB[1][icolor], RGB[2][icolor]]
           for icolor in range(ncolors_total)]
    if ncolors > ncolors_total:
        raise IOError("You can't readily distinguish that many colors")

    # ------------------------------------------------------------------------
    # Convert to Lab color space which better represents human perception:
    # ------------------------------------------------------------------------
    # https://python-colormath.readthedocs.io/en/latest/illuminants.html
    lab_colors = []
    for rgb in RGB:
        lab = convert_color(AdobeRGBColor(rgb[0],
                                          rgb[1],
                                          rgb[2]), LabColor)
        lab_colors.append(lab)

    bg_lab_colors = []
    for bg_rgb in backgrounds:
        bg_lab = convert_color(AdobeRGBColor(bg_rgb[0],
                                             bg_rgb[1],
                                             bg_rgb[2]), LabColor)
        bg_lab_colors.append(bg_lab)

    # ------------------------------------------------------------------------
    # If the user specified multiple background colors, compute differences
    # between the candidate colors and the background colors:
    # ------------------------------------------------------------------------
    min_dx = np.inf * np.ones(ncolors_total)
    if backgrounds:
        for bg_lab_color in bg_lab_colors:
            # Store difference from closest previously-chosen color:
            for icolor_total, lab_color in enumerate(lab_colors):
                dx = delta_e_cie2000(lab_color, bg_lab_color)
                min_dx[icolor_total] = min(dx, min_dx[icolor_total])

    # ------------------------------------------------------------------------
    # Iteratively pick the color that maximizes the difference
    # with the nearest already-picked color:
    # ------------------------------------------------------------------------
    # Initialize by making the "previous" color equal to the last background:
    last_lab_color = bg_lab_colors[-1]
    colors = np.zeros((ncolors, 3))
    for icolor in range(ncolors):

        # Find the difference of the last color from all colors on the list:
        for icolor_total, lab_color in enumerate(lab_colors):
            dx = delta_e_cie2000(lab_color, last_lab_color)
            min_dx[icolor_total] = min(dx, min_dx[icolor_total])

        # Find the entry farthest from all previously chosen colors:
        imax_dx = np.argmax(min_dx)

        # Store distant color:
        colors[icolor] = RGB[imax_dx]

        # Prepare for next iteration:
        last_lab_color = lab_colors[imax_dx]

    # ------------------------------------------------------------------------
    # Plot the colormap as a horizontal bar chart:
    # ------------------------------------------------------------------------
    if plot_colormap:
        if verbose:
            print("RGB values:")
        plt.figure(ncolors, figsize=(5, 10))
        for icolor in range(ncolors):
            ax = plt.subplot(ncolors, 1, icolor + 1)
            plt.axis("off")
            rgb = colors[icolor]
            #rgb = [[rgb.rgb_r, rgb.rgb_g, rgb.rgb_b]]
            if verbose:
                print(rgb)
            plt.barh(0, 50, 1, 0, color=rgb)
            plt.savefig(filename + ".png")
        if verbose:
            print("Colormap image saved to {0}".format(filename + ".png"))

    # ------------------------------------------------------------------------
    # Save the colormap as a csv file:
    # ------------------------------------------------------------------------
    if save_csv:
        np.savetxt(filename + ".csv", colors, fmt='%.18e', delimiter=',',
                   newline='\n', header='')
        if verbose:
            print("Colormap saved to {0}".format(filename + ".csv"))

    return colors


def label_adjacency_matrix(label_file, ignore_values=[-1, 999], add_value=0,
                           save_table=True, output_format='csv',
                           verbose=True):
    """
    Extract surface or volume label boundaries, find unique label pairs,
    and write adjacency matrix (useful for constructing a colormap).

    Parameters
    ----------
    label_file : string
        path to VTK surface file or nibabel-readable volume file with labels
    ignore_values : list of integers
        labels to ignore
    add_value : integer
        value to add to labels
    matrix : pandas dataframe
        adjacency matrix
    save_table : Boolean
        output table file?
    output_format : string
        format of adjacency table file name (currently only 'csv')
    verbose : Boolean
        print to stdout?

    Returns
    -------
    labels : list
        label numbers
    matrix : pandas DataFrame
        adjacency matrix
    output_table : string
        adjacency table file name

    Examples
    --------
    >>> from mindboggle.mio.colors import label_adjacency_matrix
    >>> from mindboggle.mio.fetch_data import prep_tests
    >>> urls, fetch_data = prep_tests()
    >>> ignore_values = [-1, 0]
    >>> add_value = 0
    >>> save_table = False
    >>> output_format = 'csv'
    >>> verbose = False
    >>> label_file = fetch_data(urls['left_manual_labels'], '', '.vtk')
    >>> labels, matrix, output_table = label_adjacency_matrix(label_file,
    ...     ignore_values, add_value, save_table, output_format, verbose)
    >>> matrix.lookup([20,21,22,23,24,25,26,27,28,29],
    ...               [35,35,35,35,35,35,35,35,35,35])
    array([ 0.,  1.,  0.,  0.,  0.,  0.,  0.,  1.,  1.,  1.])

    >>> label_file = fetch_data(urls['freesurfer_labels'], '', '.nii.gz')
    >>> labels, matrix, output_table = label_adjacency_matrix(label_file,
    ...     ignore_values, add_value, save_table, output_format, verbose)
    >>> matrix.lookup([4,5,7,8,10,11,12,13,14,15], [4,4,4,4,4,4,4,4,4,4])
    array([ 1.,  1.,  0.,  0.,  0.,  1.,  0.,  0.,  1.,  0.])

    """
    import numpy as np
    import pandas as pd
    from nibabel import load
    from scipy import ndimage

    from mindboggle.guts.mesh import find_neighbors
    from mindboggle.guts.segment import extract_borders
    from mindboggle.mio.vtks import read_vtk

    # Use Mindboggle's extract_borders() function for surface VTK files:
    if label_file.endswith('.vtk'):
        f1,f2,f3, faces, labels, f4, npoints, f5 = read_vtk(label_file,
                                                            True, True)
        neighbor_lists = find_neighbors(faces, npoints)
        return_label_pairs = True
        indices_borders, label_pairs, f1 = extract_borders(list(range(npoints)),
            labels, neighbor_lists, ignore_values, return_label_pairs)

        output_table = 'adjacent_surface_labels.' + output_format

    # Use scipy to dilate volume files to find neighboring labels:
    elif label_file.endswith('.nii.gz'):

        L = load(label_file).get_data()
        unique_volume_labels = np.unique(L)

        label_pairs = []
        for label in unique_volume_labels:

            if label not in ignore_values:

                B = L * np.logical_xor(ndimage.binary_dilation(L==int(label)),
                                       (L==int(label)))
                neighbor_labels = np.unique(np.ravel(B))

                for neigh in neighbor_labels:
                    if neigh > 0 and neigh in unique_volume_labels:
                    #        and neigh%2==(int(label)%2):
                        label_pairs.append([int(label), int(neigh)])

        output_table = 'adjacent_volume_labels.' + output_format

    else:
        raise IOError("Use appropriate input file type.")

    # Find unique pairs (or first two of each list):
    pairs = []
    for pair in label_pairs:
        new_pair = [int(pair[0]) + add_value,
                    int(pair[1]) + add_value]
        if new_pair not in pairs:
            pairs.append(new_pair)

    # Write adjacency matrix:
    unique_labels = np.unique(pairs)
    nlabels = np.size(unique_labels)
    matrix = np.zeros((nlabels, nlabels))
    for pair in pairs:
        index1 = np.where(unique_labels == pair[0])[0][0]
        index2 = np.where(unique_labels == pair[1])[0][0]
        matrix[index1, index2] = 1

    df1 = pd.DataFrame({'ID': unique_labels}, index=None)
    df2 = pd.DataFrame(matrix, index=None)
    df2.columns = unique_labels
    matrix = pd.concat([df1, df2], axis=1)

    if save_table:
        if output_format == 'csv':
            matrix.to_csv(output_table, index=False)
            if verbose:
                print("Adjacency matrix saved to {0}".format(output_table))
        else:
            raise IOError("Set appropriate output file format.")
    else:
        output_table = None

    labels = list(unique_labels)

    return labels, matrix, output_table


def braincolors(colormap, adjacency_matrix, weights=False,
                IDs=[], names=[], groups=[],
                save_csv=True, save_json=True, plot_colors=True,
                plot_graphs=True, out_dir='.', verbose=True):
    """
    This program takes in a colormap and table with an adjacency matrix,
    where each non-zero value signifies adjacency between labels,
    and reorganizes the colormap so that adjacent labels have
    maximally distinguishable colors in the colormap, with the option
    of specifying groups of labels to have similar colors:

    1. Read in the table with a binary (or weighted) adjacency matrix,
       where each row or column represents a label, and each value signifies
       whether (or the degree to which) a given pair of labels are adjacent.
         Example:
            column 0 = label ID number
            column 1 = label name
            column 2 = group number (each label is assigned to a group)
    2. Convert the matrix to a graph, where each node represents a label
       and each edge represents the adjacency value between connected nodes.
    4. Break up the graph into subgraphs, where each subgraph represents
       a group of adjacent labels (assigned the same group number).
    5. Compute every permutation of colors for the nodes of each subgraph,
       with similar colors in the color space.
    6. Assign each edge in each subgraph the value of the color difference
       between the colors assigned to its pair of connected nodes.
       (Multiply the connection matrix for each subgraph by
        the color difference matrix for each permutation.)
    7. Find the optimal colors for the subgraph nodes that maximizes the sum
       of the edge values.
    8. Plot the colormap, the whole graph, or individual colored subgraphs.

    Note: Install pydotplus with the other python libraries imported below.

    Parameters
    ----------
    colormap : string or numpy ndarray of ndarrays of 3 floats between 0 and 1
        csv file containing rgb colormap, or colormap array
    adjacency_matrix : string or NxN numpy ndarray (N = number of labels)
        csv file containing label adjacency matrix or matrix itself
    weights : Boolean
        use weights in adjacency matrix?
    IDs : list of integers
        label ID numbers
    names : list of strings
        label names
    groups : list of integers
        label group numbers (one per label)
    save_csv : Boolean
        save colormap as csv file?
    save_json : Boolean
        save colormap as json file?
    plot_colors : Boolean
        plot colormap as horizontal bar chart?
    plot_graphs : Boolean
        plot colormap as graphs?
    out_dir : string
        output directory path
    verbose : Boolean
        print to stdout?

    Returns
    -------
    colors : numpy ndarray of ndarrays of 3 floats between 0 and 1
        rgb colormap

    Examples
    --------
    >>> # Get colormap:
    >>> from mindboggle.mio.colors import distinguishable_colors
    >>> colormap = distinguishable_colors(ncolors=31,
    ...     backgrounds=[[0,0,0],[1,1,1]],
    ...     save_csv=False, plot_colors=False, verbose=False)
    >>> # Get adjacency matrix:
    >>> from mindboggle.mio.colors import label_adjacency_matrix
    >>> from mindboggle.mio.fetch_data import prep_tests
    >>> urls, fetch_data = prep_tests()
    >>> label_file = fetch_data(urls['left_manual_labels'], '', '.vtk')
    >>> IDs, adjacency_matrix, output_table = label_adjacency_matrix(label_file,
    ...     ignore_values=[-1, 0], add_value=0, save_table=False,
    ...     output_format='', verbose=False)
    >>> # Reorganize colormap:
    >>> from mindboggle.mio.colors import braincolors
    >>> from mindboggle.mio.labels import DKTprotocol
    >>> dkt = DKTprotocol()
    >>> names = dkt.left_cerebrum_cortex_DKT31_names
    >>> groups = dkt.DKT31_groups
    >>> weights = False
    >>> save_csv = True #False
    >>> save_json = True #False
    >>> plot_colors = True #False
    >>> plot_graphs = True #False
    >>> out_dir = '.'
    >>> verbose = True #False
    >>> colors = braincolors(colormap, adjacency_matrix, weights,
    ...     plot_graphs, IDs, names, groups, save_csv, save_json,
    ...     plot_colors, out_dir, verbose)
    >>> colors[0]
    array([ 0.62068966,  0.06896552,  1.        ])
    >>> colors[1]
    array([ 0.       ,  0.5862069,  0.       ])
    >>> colors[2]
    array([ 0.75862069,  0.20689655,  0.        ])

    """
    import os
    import pandas as pd
    import numpy as np
    import matplotlib.pyplot as plt
    import networkx as nx
    from colormath.color_diff import delta_e_cie2000
    from colormath.color_objects import LabColor, AdobeRGBColor
    from colormath.color_conversions import convert_color

    # ------------------------------------------------------------------------
    # Set parameters for graph layout and output files:
    # ------------------------------------------------------------------------
    graph_node_color = 'yellow'
    graph_node_size = 1000
    graph_edge_width = 2
    graph_font_size = 10
    subgraph_node_size = 3000
    subgraph_edge_width = 5
    subgraph_font_size = 18
    axis_buffer = 10

    colormap_csv_file = os.path.join(out_dir, 'label_colormap.csv')
    colormap_json_file = os.path.join(out_dir, 'label_colormap.json')
    colormap_image_file = os.path.join(out_dir, 'label_colormap.png')
    graph_image_file = os.path.join(out_dir, "label_graph.png")
    subgraph_image_file_pre = os.path.join(out_dir, "label_subgraph")
    subgraph_image_file_post = ".png"

    # ------------------------------------------------------------------------
    # Load colormap:
    # ------------------------------------------------------------------------
    if verbose:
        print("Load colormap and convert to CIELAB color space.")
    if isinstance(colormap, np.ndarray):
        colors = colormap
    elif isinstance(colormap, str):
        colors = pd.read_csv(colormap, sep=',', header=None)
        colors = colors.values
    else:
        raise IOError("Please use correct format for colormap.")
    nlabels = np.shape(colors)[0]
    new_colors = np.copy(colors)

    # ------------------------------------------------------------------------
    # Convert to Lab color space which better represents human perception:
    # ------------------------------------------------------------------------
    # https://python-colormath.readthedocs.io/en/latest/illuminants.html
    lab_colors = []
    for rgb in colors:
        lab_color = convert_color(AdobeRGBColor(rgb[0],
                                                rgb[1],
                                                rgb[2]), LabColor)
        lab_colors.append(lab_color)

    # ------------------------------------------------------------------------
    # Label adjacency matrix:
    # ------------------------------------------------------------------------
    if verbose:
        print("Load label adjacency matrix and convert to a graph.")
    if isinstance(adjacency_matrix, np.ndarray):
        matrix = adjacency_matrix
    elif isinstance(adjacency_matrix, str):
        matrix = pd.read_csv(adjacency_matrix, sep=',', header=None)
        matrix = matrix.values
        IDs = matrix.ID
        names = matrix.name
        groups = matrix.group
    else:
        raise IOError("Please use correct format for adjacency matrix.")

    adjacency_values = matrix[[str(x) for x in IDs]].values
    # Normalize adjacency values:
    if weights:
        adjacency_values = adjacency_values / np.max(adjacency_values)
    if np.shape(adjacency_values)[0] != nlabels:
        raise IOError("The colormap and label adjacency matrix don't have "
                      "the same number of labels.")

    # ------------------------------------------------------------------------
    # Convert (weighted) connection matrix to (weighted) graph:
    # ------------------------------------------------------------------------
    adjacency_graph = nx.from_numpy_matrix(adjacency_values)

    for inode in range(nlabels):
        adjacency_graph.node[inode]['ID'] = IDs[inode]
        adjacency_graph.node[inode]['label'] = names[inode]
        adjacency_graph.node[inode]['group'] = groups[inode]

    # ------------------------------------------------------------------------
    # Create a similarity matrix for pairs of colors:
    # ------------------------------------------------------------------------
    if verbose:
        print("Create a similarity matrix for pairs of colors.")
    dx_matrix = np.zeros((nlabels, nlabels))
    for icolor1 in range(nlabels):
        for icolor2 in range(nlabels):
            dx_matrix[icolor1,icolor2] = delta_e_cie2000(lab_colors[icolor1],
                                                         lab_colors[icolor2])

    # ------------------------------------------------------------------------
    # Loop through subgraphs:
    # ------------------------------------------------------------------------
    icolors_to_pick = range(nlabels)
    for label_group in np.unique(groups):
        if verbose:
            print("Subgraph for group {0}...".format(label_group))
        isubgraph = np.where(matrix.group == label_group)[0]
        subgraph = adjacency_graph.subgraph(isubgraph)
        N = len(isubgraph)

        # --------------------------------------------------------------------
        # Select colors for group that are similar to first unpicked color:
        # --------------------------------------------------------------------
        ipicks = np.where(np.argsort(dx_matrix[icolors_to_pick[0], :]) < N)[0]
        icolors_to_pick = np.delete(icolors_to_pick, ipicks)
        group_colors = [list(colors[x]) for x in ipicks]
        group_lab_colors = [lab_colors[x] for x in ipicks]

        # # --------------------------------------------------------------------
        # # Compute differences between every pair of colors within group:
        # # --------------------------------------------------------------------
        # if run_permutations:
        #     permutation_max = np.zeros(N)
        #     NxN_matrix = np.zeros((N, N))
        #
        #     # ----------------------------------------------------------------
        #     # Convert subgraph into an adjacency matrix:
        #     # ----------------------------------------------------------------
        #     neighbor_matrix = np.array(nx.to_numpy_matrix(subgraph,
        #                                     nodelist=isubgraph))
        #     if weights:
        #         pass
        #     else:
        #         neighbor_matrix = (neighbor_matrix > 0).astype(np.uint8)
        #
        #     # ----------------------------------------------------------------
        #     # Permute colors and color pair differences:
        #     # ----------------------------------------------------------------
        #     DEmax = 0
        #     permutations = [np.array(s) for s
        #                     in itertools.permutations(range(0, N), N)]
        #     if verbose:
        #         print(" ".join([str(N),'labels,',
        #                         str(len(permutations)),
        #                         'permutations:']))
        #
        #     for permutation in permutations:
        #         delta_matrix = NxN_matrix.copy()
        #         for i1 in range(N):
        #           for i2 in range(N):
        #             if (i2 > i1) and (neighbor_matrix[i1, i2] > 0):
        #               delta_matrix[i1,i2] = delta_e_cie2000(group_lab_colors[i1],
        #                                                     group_lab_colors[i2])
        #         if weights:
        #             DE = np.sum((delta_matrix * neighbor_matrix))
        #         else:
        #             DE = np.sum(delta_matrix)
        #
        #         # ------------------------------------------------------------
        #         # Store color permutation with maximum adjacency cost:
        #         # ------------------------------------------------------------
        #         if DE > DEmax:
        #             DEmax = DE
        #             permutation_max = permutation
        #
        #     # ----------------------------------------------------------------
        #     # Reorder subgraph colors according to the maximum adjacency cost:
        #     # ----------------------------------------------------------------
        #     group_colors = [group_colors[x] for x in permutation_max]
        #     new_colors[ipicks] = group_colors

        # --------------------------------------------------------------------
        # Draw a figure of the colored subgraph:
        # --------------------------------------------------------------------
        if plot_graphs:
            plt.figure(label_group)

            # Layout:
            pos = nx.nx_pydot.graphviz_layout(subgraph,
                                              prog="neato")
            nx.draw(subgraph, pos, node_size=subgraph_node_size,
                    width=subgraph_edge_width, alpha=0.5,
                    with_labels=False)

            # Labels:
            labels={}
            for iN in range(N):
                labels[subgraph.nodes()[iN]] = \
                    subgraph.node[subgraph.nodes()[iN]]['label']
            nx.draw_networkx_labels(subgraph, pos, labels,
                                    font_size=subgraph_font_size,
                                    font_color='black')
            # Nodes:
            nodelist = list(subgraph.node.keys())
            for iN in range(N):
                nx.draw_networkx_nodes(subgraph, pos,
                    node_size=subgraph_node_size,
                    nodelist=[nodelist[iN]],
                    node_color=group_colors[iN])

            # Figure:
            ax = plt.gca().axis()
            plt.gca().axis([ax[0]-axis_buffer, ax[1]+axis_buffer,
                            ax[2]-axis_buffer, ax[3]+axis_buffer])
            plt.savefig(subgraph_image_file_pre +
                        str(int(subgraph.node[subgraph.nodes()[0]]['ID'])) +
                        subgraph_image_file_post)
            plt.axis('off')
            plt.show()

    # ------------------------------------------------------------------------
    # Plot the whole graph:
    # ------------------------------------------------------------------------
    if plot_graphs:
        plt.figure(nlabels + 1)

        # Graph:
        pos = nx.nx_pydot.graphviz_layout(adjacency_graph, prog="neato")
        nx.draw(adjacency_graph, pos,
                node_color=graph_node_color,
                node_size=graph_node_size,
                width=graph_edge_width,
                with_labels=False)
        # Nodes:
        nodelist = list(adjacency_graph.node.keys())
        for icolor, new_color in enumerate(new_colors):
            nx.draw_networkx_nodes(adjacency_graph, pos,
                                   node_size=graph_node_size,
                                   nodelist=[nodelist[icolor]],
                                   node_color=new_color)
        # Labels:
        labels={}
        for ilabel in range(nlabels):
            labels[ilabel] = adjacency_graph.node[ilabel]['label']
        nx.draw_networkx_labels(adjacency_graph, pos, labels,
                                font_size=graph_font_size,
                                font_color='black')
        plt.axis('off')
        plt.savefig(graph_image_file)
        plt.show()

    # ------------------------------------------------------------------------
    # Plot the colormap as a horizontal bar chart:
    # ------------------------------------------------------------------------
    if plot_colors:
        plt.figure(nlabels, figsize=(5, 10))
        for ilabel in range(nlabels):
            ax = plt.subplot(nlabels, 1, ilabel + 1)
            plt.axis("off")
            rgb = colors[ilabel]
            plt.barh(0, 50, 1, 0, color=rgb)
        plt.savefig(colormap_image_file)
        plt.show()

    # ------------------------------------------------------------------------
    # Save csv file with colormap:
    # ------------------------------------------------------------------------
    if save_csv:
        np.savetxt(colormap_csv_file, new_colors, fmt='%.18e', delimiter=',',
                   newline='\n', header='')

    # ------------------------------------------------------------------------
    # Save json file with colormap:
    # ------------------------------------------------------------------------
    if save_json:
        fjson = open(colormap_json_file,'w')
    print(
        '<ColorMap name="Mindboggle Colormap" space="RGB" indexedLookup="false">')
    print('  <NaN r="0" g="0" b="0"/>')
    print('  <Point x="-1" o="0"  r="0" g="0" b="0"/>')
    for row in colormap:
        print('  <Point x="{0}" o="1"  '
              'r="{1:1.2f}" g="{2:1.2f}" b="{3:1.2f}"/>'.
              format(row[0], row[2], row[3], row[4]))
    print('</ColorMap>')


    return new_colors
